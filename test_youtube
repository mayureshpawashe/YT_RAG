import os
import re
import pickle
from typing import Optional, Dict, Any
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from config import Config

# DEFINE THE SCOPE: This asks for read-only permission for YouTube.
# Update the SCOPES at the top of the file
SCOPES = [
    'https://www.googleapis.com/auth/youtube.readonly',
    'https://www.googleapis.com/auth/youtube.force-ssl'  # Add this scope for captions
]

class YouTubeLoader:
    """Load and process YouTube video transcripts using official YouTube Data API"""
    
    def __init__(self):
        self.transcripts_dir = Config.TRANSCRIPTS_DIR
        
        # Get credentials
        creds = self._get_credentials()
        
        # Initialize YouTube API client using credentials
        self.youtube = build('youtube', 'v3', credentials=creds)
    
    def _get_credentials(self):
        """
        Get user credentials.
        - Tries to load credentials from 'token.pickle'.
        - If not found or invalid, runs the OAuth 2.0 flow.
        """
        creds = None
        
        # The file token.pickle stores the user's access and refresh tokens.
        if os.path.exists('token.pickle'):
            with open('token.pickle', 'rb') as token:
                creds = pickle.load(token)
        
        # If there are no (valid) credentials available, let the user log in.
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                print("Refreshing expired credentials...")
                creds.refresh(Request())
            else:
                print("No valid credentials found. Please log in via browser...")
                flow = InstalledAppFlow.from_client_secrets_file(
                    'client_secret.json', SCOPES)
                # run_local_server will open a browser for the user to log in
                creds = flow.run_local_server(port=0)
            
            # Save the credentials for the next run
            with open('token.pickle', 'wb') as token:
                pickle.dump(creds, token)
                print("✓ Credentials saved to 'token.pickle'")
        
        return creds

    @staticmethod
    def extract_video_id(url: str) -> Optional[str]:
        """Extract video ID from YouTube URL"""
        patterns = [
            r'(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})',
            r'(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})',
            r'(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        
        if len(url) == 11:
            return url
        
        return None
    
    def get_video_details(self, video_id: str) -> Dict[str, Any]:
        """Fetch video details using YouTube API"""
        try:
            request = self.youtube.videos().list(
                part="snippet,contentDetails",
                id=video_id
            )
            response = request.execute()
            
            if not response['items']:
                raise ValueError(f"Video not found: {video_id}")
                
            return response['items'][0]
            
        except HttpError as e:
            raise Exception(f"YouTube API error: {str(e)}")
    
    def get_transcript(self, video_url: str, languages: list = None) -> dict:
        """Fetch video transcript and details using YouTube API"""
        if languages is None:
            languages = ['en']
            
        video_id = self.extract_video_id(video_url)
        if not video_id:
            raise ValueError(f"Could not extract video ID from URL: {video_url}")
        
        try:
            video_details = self.get_video_details(video_id)
            
            request = self.youtube.captions().list(
                part="snippet",
                videoId=video_id
            )
            captions_response = request.execute()
            
            caption_track = None
            for item in captions_response.get('items', []):
                if item['snippet']['language'] in languages:
                    caption_track = item
                    break
            
            if not caption_track:
                # Fallback: check for 'en-US' or other specifics
                for item in captions_response.get('items', []):
                    if item['snippet']['language'].startswith('en'):
                        caption_track = item
                        break

            if not caption_track:
                lang_list = [item['snippet']['language'] for item in captions_response.get('items', [])]
                raise Exception(f"No captions found in languages: {languages}. Available: {lang_list}")
            
            # This is the call that failed before. It will now work.
            caption_id = caption_track['id']
            caption_request = self.youtube.captions().download(
                id=caption_id,
                tfmt='srt'  # 'srt' is a simple text format
            )
            
            # .execute() here downloads the raw caption data
            caption_data = caption_request.execute()

            # The API returns bytes, so we decode it to a string
            transcript_text = self._clean_transcript(caption_data.decode('utf-8'))
            
            result = {
                'video_id': video_id,
                'url': f"https://www.youtube.com/watch?v={video_id}",
                'title': video_details['snippet']['title'],
                'description': video_details['snippet']['description'],
                'transcript': transcript_text,
                'language': caption_track['snippet']['language'],
                'published_at': video_details['snippet']['publishedAt']
            }
            
            print(f"✓ Successfully fetched transcript for: {result['title']}")
            print(f"  Language: {result['language']}")
            print(f"  Transcript length: {len(transcript_text)} characters")
            
            return result
            
        except HttpError as e:
            # Re-raise with the detailed error message
            raise Exception(f"Error processing video {video_id}: {str(e)}")
        except Exception as e:
            raise Exception(f"Error processing video {video_id}: {str(e)}")

    def _clean_transcript(self, srt_text: str) -> str:
        """Clean transcript text from SRT format"""
        # Remove SRT timestamps (e.g., 00:00:01,000 --> 00:00:02,000)
        text = re.sub(r'\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}\r?\n', '', srt_text)
        # Remove SRT line numbers
        text = re.sub(r'^\d+\r?\n', '', text, flags=re.MULTILINE)
        # Remove empty lines
        text = re.sub(r'^\s*$', '', text, flags=re.MULTILINE)
        # Join all lines into a single string
        text = ' '.join(text.splitlines())
        return text.strip()

    # (You can add your save/load transcript methods back in here if you want)
    def save_transcript(self, video_data: dict):
        """Save transcript to a text file"""
        if not video_data.get('video_id') or not video_data.get('transcript'):
            print("! Invalid video data for saving")
            return
        
        file_path = os.path.join(self.transcripts_dir, f"{video_data['video_id']}.txt")
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(f"Title: {video_data.get('title', 'N/A')}\n")
                f.write(f"URL: {video_data.get('url', 'N/A')}\n")
                f.write(f"Language: {video_data.get('language', 'N/A')}\n")
                f.write(f"{'='*30}\n\n")
                f.write(video_data['transcript'])
            
            print(f"✓ Transcript saved to: {file_path}")
            
        except Exception as e:
            print(f"! Error saving transcript: {str(e)}")